## [FAQ](#!faq)

### Что такое debounce?

В документации часто встречается фраза "микропаттерн debounce". Это распространенный паттерн, который превращает несколько вызовов функции в течение определенного времени в один вызов. Подробнее в [статье на Хабрахабр](https://habrahabr.ru/post/60957/) или [на англоязычном ресурсе](https://davidwalsh.name/javascript-debounce-function)

### Как отрендерить один объект в контейнерах нескольких коллекций?

Первое: нужно установить классу этого объекта свойство ``bindRenderedAsSandbox`` со значением ``false``. Это отключает автоматическое создание песочницы при рендеринге объекта в массиве (т. к. запрещено одному объету иметь две песочницы).

Второе: по событию ``render`` проверить, в какой массив был вставлен объект и объявить байндинги, соответствующие массиву. Родительский массив и отрисоанный элемент можно получить, обратившись к свойствам ``parentArray`` и ``node`` объекта события.

Пример. Есть класс объекта ``User`` и две коллекции: ``UsersA`` и ``UsersB`` (их {@link Matreshka.Array#itemRenderer} может отличаться). Для обоих коллекций ``User`` используется в качестве {@link Matreshka.Array#Model}.

```js
class User extends Matreshka.Object {
	constructor() {
		super();

		this.bindRenderedAsSandbox = false;

		setInterval(() => {
			// изменив name изменятся и все связанные
			// с этим свойством элементы
			this.name = Math.random();
		}, 5000);
	}
	onRender(evt) {
		const { parentArray, node } = evt;

		if(parentArray instanceof UsersA) {
			this.bindNode({
				// создаём псевдо-песочницу
				// для синтаксического сахара в селекторах
				// (это не обязательно)
				nodeA: node,
				name: ':bound(nodeA) .name',
				email: ':bound(nodeA) .email',
			});
		} else if(parentArray instanceof UsersB) {
			this.bindNode({
				nodeB: node,
				name: ':bound(nodeB) .user-name',
			});
		}
	}
}
```

На самом деле есть много способов решения этой задачи. Например, можно объявлять байндинги на уровне массива (т. е. массив будет слушать событие ``render`` вставленных объектов) или на уровне массива привязывать только псевдо-песоницу, а на уровне объекта слушать событие ``bind`` и объявлять остальные привязки...

### Что из себя должно представлять крупное приложение?

Проиложение на базе Матрешки, как правило, представляет из себя один вложенный JavaScript объект, каждая ветвь которого - экземпляр {@link Matreshka}. Новые ветви приложения создаются при помощи {@link Matreshka#instantiate}, что гарантирует целостность приложения и возможность вернуть предыдущее состояние приложения или одной его ветви обычными присваиванием. За подробностями обратитесь к примерам {@link Matreshka#instantiate}.

Названия файла, содержащего класс, для наглядности, должно соответствовать имени класса (например, класс User должен находиться в файле user.js либо user/index.js), а путь к тому или иному классу должен соответствовать месту в объекте приложения (например, /admin/users/user).

### Есть ли в Матрешке роутинг?
Да, плагин [matreshka-router](https://github.com/matreshkajs/matreshka-router), реализует двустороннее связывание свойства и части URL в стиле Matreshka.js. Подробное описание на русском можно прочесть [в статье на Хабре](https://habrahabr.ru/company/matreshka/blog/277171/).

### Как работает Матрешка?
Матрешка использует акцессоры (accessors) для реализации двустороннего связывания данных и отлова событий изменения свойств.

В качестве примера того, как работает двустороннее связывание (в частности, функция {@link Matreshka.bindNode}), взгляните на этот код:
```js
function bindNode(object, key, node, binder) {
    const value = object[key];
    Object.defineProperty(object, key, {
        get() {
            return value;
        },
        set(v) {
            binder.setValue.call(node, v);
        }
    });

    node.addEventListener(binder.on, () => {
        value = binder.getValue.call(node);
    });
};
```
Для упрощения, функция не поддерживает связь многие-ко-многим и другие фичи оригинала.


### Как предварительно отрендерить приложение на сервере?

Можно использовать Matreshka.js на сервере Node.js (требуется наличие [jsdom](https://github.com/tmpvar/jsdom), а, точнее, объекта ``window``) либо возпользоваться совершенно любым шаблонизатором на любой серверной платформе. Первый вариант подходит для статичной генерации HTML, второй - для страниц, которые генерируются при каждом обращении пользователя.

Задача клиентской стороны - восстановить приложение из HTML. {@link Matreshka#bindNode} извлечет состояние элемента и присвоит его свойству, а {@link Matreshka.Array#restore} восстановит состояние коллекции.
